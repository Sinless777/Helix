#!/usr/bin/env node

import { writeFile } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const OWNER = 'Sinless777';
const REPO = 'Helix';
const PER_PAGE = 100;
const TOKEN = process.env.GITHUB_TOKEN ?? process.env.HELIX_GITHUB_TOKEN;
const USER_AGENT = 'helix-todo-sync-script';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const outputPath = resolve(__dirname, '../../Docs/TODO.md');

const sleep = (ms) => new Promise((resolveSleep) => setTimeout(resolveSleep, ms));

async function fetchIssues() {
  const all = [];
  let page = 1;

  // GitHub API best practice: provide a polite user agent and optional auth token.
  const headers = {
    Accept: 'application/vnd.github+json',
    'User-Agent': USER_AGENT,
  };

  if (TOKEN) {
    headers.Authorization = `Bearer ${TOKEN}`;
  }

  while (true) {
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/issues?state=all&per_page=${PER_PAGE}&page=${page}`;
    const response = await fetch(url, { headers });

    if (response.status === 403 && response.headers.get('x-ratelimit-remaining') === '0') {
      const reset = Number(response.headers.get('x-ratelimit-reset')) * 1000;
      const waitTime = Math.max(reset - Date.now(), 0);
      console.warn(`GitHub rate limit hit. Waiting ${Math.ceil(waitTime / 1000)}s before retrying page ${page}.`);
      await sleep(waitTime + 1000);
      continue;
    }

    if (!response.ok) {
      const message = await response.text();
      throw new Error(`Failed to fetch issues (page ${page}): ${response.status} ${response.statusText}\n${message}`);
    }

    const data = await response.json();
    if (!Array.isArray(data) || data.length === 0) {
      break;
    }

    const issues = data.filter((item) => !item.pull_request);
    all.push(...issues);

    if (data.length < PER_PAGE) {
      break;
    }

    page += 1;
    await sleep(250); // be kind to the API.
  }

  return all;
}

function escapeCell(text) {
  return text.replaceAll('|', '\\|').replaceAll('\n', ' ');
}

function formatList(items, key) {
  if (!items || items.length === 0) {
    return '—';
  }
  const values = items
    .map((item) => item?.[key])
    .filter(Boolean)
    .sort((a, b) => a.localeCompare(b));
  return values.length > 0 ? values.join(', ') : '—';
}

function buildMarkdown(issues) {
  const generatedAt = new Date().toISOString();

  const parts = [
    '---',
    'title: Helix TODO Index',
    'generated: true',
    'description: Aggregated view of GitHub issues for Helix',
    `updated_at: ${generatedAt}`,
    '---',
    '',
    '# Helix Issue Index',
    '',
    '> Auto-generated from GitHub issues. Run `pnpm run update:todo` locally or rely on the scheduled workflow to refresh.',
    '',
    '| # | Title | State | Assignees | Labels | Milestone | Updated |',
    '| - | ----- | ----- | --------- | ------ | --------- | ------- |',
  ];

  const sorted = [...issues].sort((a, b) => a.number - b.number);

  for (const issue of sorted) {
    const number = issue.number;
    const title = escapeCell(issue.title || `Issue ${number}`);
    const titleLink = `[${title}](${issue.html_url})`;
    const state = issue.state;
    const assignees = formatList(issue.assignees, 'login');
    const labels = formatList(issue.labels, 'name');
    const milestone = issue.milestone?.title ?? '—';
    const updated = issue.updated_at ? issue.updated_at.split('T')[0] : '—';

    parts.push(`| ${number} | ${titleLink} | ${state} | ${assignees} | ${labels} | ${milestone} | ${updated} |`);
  }

  parts.push('');
  parts.push('---');
  parts.push('');
  parts.push('> Automation notes: This file is generated by `tools/scripts/update-todo.mjs`. Add a scheduled GitHub Action or Nx task to run it regularly.');

  return parts.join('\n');
}

async function main() {
  try {
    const issues = await fetchIssues();
    const markdown = buildMarkdown(issues);
    await writeFile(outputPath, markdown, 'utf8');
    console.log(`Updated ${outputPath} with ${issues.length} issues.`);
  } catch (error) {
    console.error(error.message);
    process.exitCode = 1;
  }
}

await main();
