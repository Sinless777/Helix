# .github/workflows/ci.yaml
name: CI/CD Pipeline

permissions:
  contents: read
  packages: write
  statuses: write

on:
  push:
    branches:
      - master
      - develop
      - 'feature/**'
      - 'hotfix/**'
      - 'release/**'
  pull_request:
    branches:
      - master
      - develop
  # Manual trigger
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PNPM_VERSION: 10.12.4
  NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}

jobs:
  build-lint-test:
    name: Build, Lint & Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      checks: write
      packages: write
      security-events: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'pnpm'

      - name: Cache build artifacts and node_modules
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            node_modules
            dist/**/**
          key: ${{ runner.os }}-build-${{ hashFiles('**/pnpm-lock.yaml', '**/package.json', '**/tsconfig.json') }}
          restore-keys: |
            ${{ runner.os }}-build-

      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: pnpm install

      - name: Lint codebase
        run: pnpx nx run-many --target=lint --all

      - name: Check if build is needed
        id: check_diff
        run: |
          echo "::group::Checking for changes in packages..."
          git fetch origin master --depth=1 || true
          if git diff --quiet origin/master -- ':!**/*.test.ts' ':!**/*.spec.ts'; then
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "No buildable changes detected."
          else
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "Changes detected. Building packages."
          fi
          echo "::endgroup::"

      - name: Rebuild changed packages
        if: steps.check_diff.outputs.skip_build == 'false'
        run: pnpx nx run-many --target=build --all --parallel --maxParallel=3

  semantic-versioning:
    # Prepares a release PR instead of pushing directly to master (respects rulesets)
    name: Prepare Release PR (Semantic Versioning)
    needs: build-lint-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    permissions:
      contents: write
      pull-requests: write
      packages: write
      actions: read
      checks: write
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Install Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install git-cliff and jq
        run: brew install git-cliff jq

      - name: Detect next version and stage changes
        id: versioning
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          HUSKY: 0
        run: |
          set -euo pipefail

          echo "Fetching and pruning tags..."
          git fetch --tags --force --prune --prune-tags

          echo "Determining latest semver tags..."
          HIGHEST_TAG="$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1 || true)"
          REACHABLE_TAG="$(git describe --tags --abbrev=0 --match 'v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo '')"

          if [ -z "${HIGHEST_TAG}" ] && [ -z "${REACHABLE_TAG}" ]; then
            echo "No Git tags found. Starting at v1.0.0."
            BASE_VERSION="1.0.0"
            INITIAL_RELEASE=true
          else
            INITIAL_RELEASE=false
            if [ -z "${REACHABLE_TAG}" ]; then
              REACHABLE_TAG="${HIGHEST_TAG}"
            fi
            BASE_VERSION="${REACHABLE_TAG#v}"
          fi

          if [ "${INITIAL_RELEASE}" = true ]; then
            COMMITS="$(git log --pretty=format:'%s (%h)' | head -n 100)"
            NEXT_VERSION="${BASE_VERSION}"
            echo "Initial release detected; using ${NEXT_VERSION}."
          else
            echo "Gathering commits since ${REACHABLE_TAG}..."
            COMMITS="$(git log "${REACHABLE_TAG}"..HEAD --pretty=format:'%s (%h)' | head -n 100)"

            echo "Asking OpenAI whether this is a major, minor, or patch bump..."
            DECISION="$(
              curl -s https://api.openai.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -d "$(jq -n \
                      --arg commits "Commits since ${REACHABLE_TAG}:\n${COMMITS}" \
                      '{model:"gpt-4",messages:[
                        {role:"system",content:"You are a semantic versioning assistant. Only respond with '\''major'\'', '\''minor'\'', or '\''patch'\''."},
                        {role:"user",content:$commits}
                      ],temperature:0}')" \
              | jq -r '.choices[0].message.content'
            )" || DECISION=""

            case "${DECISION}" in
              major|minor|patch) echo "OpenAI decided: ${DECISION}" ;;
              *) echo "OpenAI returned '${DECISION:-null}' â€” defaulting to patch."; DECISION="patch" ;;
            esac

            IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE_VERSION}"
            case "${DECISION}" in
              major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
              patch) PATCH=$((PATCH + 1)) ;;
            esac
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          # Ensure uniqueness vs remote/local tags (for safety if tag already exists)
          echo "Ensuring future tag uniqueness..."
          git ls-remote --tags origin > /tmp/remote_tags || true
          CANDIDATE="v${NEXT_VERSION}"
          while git rev-parse -q --verify "refs/tags/${CANDIDATE}" >/dev/null || grep -q "refs/tags/${CANDIDATE}$" /tmp/remote_tags; do
            echo "Tag ${CANDIDATE} already exists; bumping patch."
            IFS='.' read -r MAJOR MINOR PATCH <<< "${NEXT_VERSION}"
            PATCH=$((PATCH + 1))
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            CANDIDATE="v${NEXT_VERSION}"
          done

          echo "next_version=${NEXT_VERSION}" >> "${GITHUB_OUTPUT}"
          echo "candidate_tag=${CANDIDATE}" >> "${GITHUB_OUTPUT}"

          echo "Updating package.json version..."
          jq ".version=\"${NEXT_VERSION}\"" package.json > tmp.json && mv tmp.json package.json
          pnpm install

          echo "Generating changelog file..."
          DATE="$(date +'%m_%d_%Y')"
          mkdir -p CHANGELOGS
          git cliff --tag "${CANDIDATE}" -o "CHANGELOGS/${DATE}-CHANGELOG-${NEXT_VERSION}.md"
          echo "Generated changelog for ${NEXT_VERSION}"

          echo "Staging files for PR..."
          git add package.json CHANGELOGS/

      - name: Create/Update release PR
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          title: "chore(release): v${{ steps.versioning.outputs.next_version }}"
          commit-message: "chore(release): v${{ steps.versioning.outputs.next_version }}"
          body: |
            Automated release preparation for **v${{ steps.versioning.outputs.next_version }}**.

            This PR updates:
            - `package.json` version
            - Adds changelog under `CHANGELOGS/`

            Once merged into `master`, a tag `${{ steps.versioning.outputs.candidate_tag }}` and GitHub Release will be created automatically.
          branch: "release/v${{ steps.versioning.outputs.next_version }}"
          base: "master"
          labels: "release"
          delete-branch: true

      - name: PR created/updated
        run: |
          echo "PR: ${{ steps.cpr.outputs.pull-request-url || 'no changes (up-to-date)' }}"

  tag-and-release:
    # After the release PR is merged to master, create the tag and GitHub Release
    name: Tag & GitHub Release (on merge)
    needs: build-lint-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    permissions:
      contents: write

    steps:
      - name: Checkout (with full history & tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install git-cliff and jq
        run: brew install git-cliff jq

      - name: Determine version and decide if this is a release commit
        id: detect
        run: |
          set -euo pipefail

          VERSION="$(jq -r '.version' package.json)"
          TAG="v${VERSION}"

          echo "Current package.json version: ${VERSION}"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

          # Only proceed if package.json changed in this commit (typical for release PR)
          if [ "$(git rev-parse --verify HEAD^ 2>/dev/null || echo '')" != "" ] && \
             ! git diff --name-only HEAD^ HEAD | grep -q '^package.json$'; then
            echo "package.json did not change in this commit; skipping tag/release."
            echo "do_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Skip if tag already exists remotely or locally
          git fetch --tags --force --prune --prune-tags
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null || \
             git ls-remote --tags origin | grep -q "refs/tags/${TAG}$"; then
            echo "Tag ${TAG} already exists; nothing to do."
            echo "do_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "do_release=true" >> "$GITHUB_OUTPUT"

      - name: Create tag
        if: steps.detect.outputs.do_release == 'true'
        run: |
          TAG="${{ steps.detect.outputs.tag }}"
          echo "Creating tag ${TAG}..."
          git tag "${TAG}"
          git push origin "${TAG}"

      - name: Generate release notes
        if: steps.detect.outputs.do_release == 'true'
        id: notes
        run: |
          TAG="${{ steps.detect.outputs.tag }}"
          DATE="$(date +'%m_%d_%Y')"
          OUT="CHANGELOGS/${DATE}-CHANGELOG-${TAG#v}.md"

          mkdir -p CHANGELOGS
          git cliff --tag "${TAG}" -o "${OUT}"

          echo "notes_path=${OUT}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        if: steps.detect.outputs.do_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.detect.outputs.tag }}
          name: ${{ steps.detect.outputs.tag }}
          body_path: ${{ steps.notes.outputs.notes_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
