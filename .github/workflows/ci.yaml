# .github/workflows/ci.yaml
name: CI/CD Pipeline

permissions:
  contents: read
  packages: write
  statuses: write

on:
  push:
    branches:
      - master
      - develop
      - 'feature/**'
      - 'hotfix/**'
      - 'release/**'
  pull_request:
    branches:
      - master
      - develop

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PNPM_VERSION: 10.12.4

jobs:
  build-lint-test:
    name: Build, Lint & Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      checks: write
      packages: write
      security-events: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'pnpm'

      - name: Cache build artifacts and node_modules
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            node_modules
            dist/**/**
          key: ${{ runner.os }}-build-${{ hashFiles('**/pnpm-lock.yaml', '**/package.json', '**/tsconfig.json') }}
          restore-keys: |
            ${{ runner.os }}-build-

      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: pnpm install

      - name: Lint codebase
        run: pnpx nx run-many --target=lint --all

      - name: Check if build is needed
        id: check_diff
        run: |
          echo "::group::Checking for changes in packages..."
          git fetch origin master --depth=1 || true
          if git diff --quiet origin/master -- ':!**/*.test.ts' ':!**/*.spec.ts'; then
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "No buildable changes detected."
          else
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "Changes detected. Building packages."
          fi
          echo "::endgroup::"

      - name: Rebuild changed packages
        if: steps.check_diff.outputs.skip_build == 'false'
        run: pnpx nx run-many --target=build --all --parallel --maxParallel=3

  semantic-versioning:
    name: Semantic Versioning
    needs: build-lint-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: write
      actions: read
      checks: write
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Install Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install git-cliff and jq
        run: brew install git-cliff jq

      - name: Detect version, bump, tag, and generate changelog
        id: versioning
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HUSKY: 0
        run: |
          set -euo pipefail

          echo "Fetching and pruning tags..."
          git fetch --tags --force --prune --prune-tags

          echo "Determining latest semver tags..."
          # Highest semver tag anywhere in the repo
          HIGHEST_TAG="$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1 || true)"
          # Latest semver tag reachable from HEAD (may be different from HIGHEST_TAG)
          REACHABLE_TAG="$(git describe --tags --abbrev=0 --match 'v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo '')"

          if [ -z "${HIGHEST_TAG}" ] && [ -z "${REACHABLE_TAG}" ]; then
            echo "No Git tags found. Starting at v1.0.0."
            BASE_VERSION="1.0.0"
            INITIAL_RELEASE=true
          else
            INITIAL_RELEASE=false
            # If nothing reachable, fall back to the highest tag so we still have a base
            if [ -z "${REACHABLE_TAG}" ]; then
              REACHABLE_TAG="${HIGHEST_TAG}"
            fi
            BASE_VERSION="${REACHABLE_TAG#v}"
          fi

          # Collect commits to decide bump
          if [ "${INITIAL_RELEASE}" = true ]; then
            COMMITS="$(git log --pretty=format:'%s (%h)' | head -n 100)"
            NEXT_VERSION="${BASE_VERSION}"
            echo "Initial release detected; using ${NEXT_VERSION}."
          else
            echo "Gathering commits since ${REACHABLE_TAG}..."
            COMMITS="$(git log "${REACHABLE_TAG}"..HEAD --pretty=format:'%s (%h)' | head -n 100)"

            echo "Asking OpenAI whether this is a major, minor, or patch bump..."
            DECISION="$(
              curl -s https://api.openai.com/v1/chat/completions \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -d "$(jq -n \
                      --arg commits "Commits since ${REACHABLE_TAG}:\n${COMMITS}" \
                      '{model:"gpt-4",messages:[
                        {role:"system",content:"You are a semantic versioning assistant. Only respond with '\''major'\'', '\''minor'\'', or '\''patch'\''."},
                        {role:"user",content:$commits}
                      ],temperature:0}')" \
              | jq -r '.choices[0].message.content'
            )" || DECISION=""

            case "${DECISION}" in
              major|minor|patch) echo "OpenAI decided: ${DECISION}" ;;
              *) echo "OpenAI returned '${DECISION:-null}' â€” defaulting to patch."; DECISION="patch" ;;
            esac

            IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE_VERSION}"
            case "${DECISION}" in
              major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
              patch) PATCH=$((PATCH + 1)) ;;
            esac
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          # Ensure uniqueness vs local and remote tags; bump patch until free
          echo "Ensuring tag uniqueness..."
          git ls-remote --tags origin > /tmp/remote_tags || true
          CANDIDATE="v${NEXT_VERSION}"
          while git rev-parse -q --verify "refs/tags/${CANDIDATE}" >/dev/null || grep -q "refs/tags/${CANDIDATE}$" /tmp/remote_tags; do
            echo "Tag ${CANDIDATE} already exists; bumping patch."
            IFS='.' read -r MAJOR MINOR PATCH <<< "${NEXT_VERSION}"
            PATCH=$((PATCH + 1))
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            CANDIDATE="v${NEXT_VERSION}"
          done

          echo "Final next version: ${NEXT_VERSION}"
          echo "next_version=${NEXT_VERSION}" >> "${GITHUB_OUTPUT}"
          echo "should_release=true" >> "${GITHUB_OUTPUT}"

          echo "Updating package.json version..."
          jq ".version=\"${NEXT_VERSION}\"" package.json > tmp.json && mv tmp.json package.json
          pnpm install

          echo "Configuring git user..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Committing version changes if any..."
          if ! git diff --quiet; then
            git commit -am "chore(release): v${NEXT_VERSION}"
          else
            echo "No file changes to commit."
          fi

          echo "Pushing commit..."
          git push origin HEAD

          echo "Creating and pushing tag ${CANDIDATE}..."
          git tag "${CANDIDATE}" || git tag -f "${CANDIDATE}"
          # No force is expected after uniqueness loop, but keep a guard
          git push origin "${CANDIDATE}" || git push --force-with-lease origin "${CANDIDATE}"

          echo "Generating changelog..."
          DATE="$(date +'%m_%d_%Y')"
          mkdir -p CHANGELOGS
          git cliff --tag "${CANDIDATE}" -o "CHANGELOGS/${DATE}-CHANGELOG-${NEXT_VERSION}.md"
          echo "Generated changelog for ${NEXT_VERSION}"

          echo "Committing changelog..."
          git add CHANGELOGS/ package.json
          if ! git diff --cached --quiet; then
            git commit -m "docs(changelog): add changelog for v${NEXT_VERSION}"
            git push origin HEAD
          else
            echo "No changelog changes to commit."
          fi
