# .github/workflows/assign.yaml
name: ðŸ‘¥ Auto-assign, label & milestone (issues & PRs)

on:
  issues:
    types: [opened, edited, labeled, reopened]
  pull_request_target:
    types: [opened, ready_for_review, reopened, synchronize, edited, labeled]

permissions:
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: auto-assign-${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  assign:
    name: Process issue/PR
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.base.ref || github.ref_name }}

      - name: Install YAML parser
        run: npm install -g yaml

      - name: Apply assignment rules
        uses: actions/github-script@v8
        env:
          CONFIG_FILE: .github/assignees.yaml
        with:
          script: |
            const fs = require('fs');
            const { parse } = require('yaml');
            const core = require('@actions/core');
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const actor = context.actor;
            const isPR = !!context.payload.pull_request;
            const number = isPR ? context.payload.pull_request.number : context.payload.issue.number;

            function readConfig(path) {
              if (!fs.existsSync(path)) {
                core.warning(`Config file not found: ${path}`);
                return {};
              }
              try {
                return parse(fs.readFileSync(path, 'utf8'));
              } catch (error) {
                core.setFailed(`Failed to parse ${path}: ${error}`);
              }
            }

            const cfg = readConfig(process.env.CONFIG_FILE) || {};
            const rules = cfg.rules || {};
            const fallback = cfg.default || { assignees: [], reviewers: [] };

            // Get current item data
            const data = isPR
              ? (await github.rest.pulls.get({ owner, repo, pull_number: number })).data
              : (await github.rest.issues.get({ owner, repo, issue_number: number })).data;

            const title = data.title || '';
            const existingLabels = new Set((data.labels || []).map(l => typeof l === 'string' ? l : l.name));

            // Determine key for rule lookup
            let key = null;
            // 1) labelâ€driven
            for (const lbl of existingLabels) {
              if (rules[lbl]) {
                key = lbl;
                break;
              }
            }
            // 2) actorâ€driven for bots
            if (!key) {
              if (actor === 'renovate[bot]') key = 'renovate';
              else if (actor === 'dependabot[bot]') key = 'dependabot';
              else if (actor === 'github-actions[bot]') key = 'ci';
            }
            // 3) titleâ€driven heuristics
            if (!key) {
              const t = title.toLowerCase();
              if (/\bbug|\bfix|\bregression/.test(t)) key = 'type:bug';
              else if (/\bfeature|\benhancement|\bfeat/.test(t)) key = 'type:feature';
              else if (/\bchore|\brefactor|\bcleanup/.test(t)) key = 'type:chore';
              else if (/\bsecurity|\bcve|\bvuln/.test(t)) key = 'type:security';
              else if (/\bdocs?/.test(t)) key = 'type:docs';
            }

            const rule = key && rules[key] ? rules[key] : fallback;

            // Prepare actions
            const labelsToAdd = [];
            if (key && key.includes(':') && !existingLabels.has(key)) {
              labelsToAdd.push(key);
            }

            const assignees = Array.from(new Set([...(rule.assignees || []), ...(fallback.assignees || [])]))
                              .filter(Boolean);
            const reviewers = isPR
              ? Array.from(new Set([...(rule.reviewers || []), ...(fallback.reviewers || [])]))
                  .filter(Boolean)
              : [];

            // Always ensure your username is present
            if (!assignees.includes('Sinless777')) {
              assignees.unshift('Sinless777');
            }

            // Apply labels
            if (labelsToAdd.length) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: labelsToAdd });
              core.info(`Added label(s): ${labelsToAdd}`);
            }

            // Assign users
            if (assignees.length) {
              try {
                await github.rest.issues.addAssignees({ owner, repo, issue_number: number, assignees });
                core.info(`Assigned: ${assignees}`);
              } catch (e) {
                core.warning(`Failed to assign: ${e.message}`);
              }
            }

            // Request reviewers on PR
            if (isPR && reviewers.length) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner, repo,
                  pull_number: number,
                  reviewers: reviewers.filter(u => !u.endsWith('[bot]'))
                });
                core.info(`Requested reviewers: ${reviewers}`);
              } catch (e) {
                core.warning(`Failed to request reviewers: ${e.message}`);
              }
            }

            // Milestone logic (optional but recommended)
            const milestones = await github.paginate(github.rest.issues.listMilestones, {
              owner, repo, state: 'open', per_page: 100
            });
            const norm = s => s.toLowerCase().replace(/[\s\p{Emoji}â€”â€“-]/gu, '');
            const findMilestone = (search) => milestones.find(m => norm(m.title).includes(norm(search)));
            let selectedMilestone = null;

            // Try match semantic version like vX.Y.Z
            const versionMatch = title.match(/\bv?(\d+\.\d+\.\d+)\b/);
            if (versionMatch) {
              selectedMilestone = findMilestone(versionMatch[1]);
            }
            // Security key
            if (!selectedMilestone && key === 'type:security') {
              selectedMilestone = findMilestone('security');
            }
            // Bot updates
            if (!selectedMilestone && actor === 'renovate[bot]') {
              selectedMilestone = findMilestone('renovate');
            }
            // Fallback to backlog
            if (!selectedMilestone) {
              selectedMilestone = findMilestone('backlog');
            }

            if (selectedMilestone && data.milestone?.number !== selectedMilestone.number) {
              try {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: number,
                  milestone: selectedMilestone.number
                });
                core.info(`Milestone set to: ${selectedMilestone.title}`);
              } catch (e) {
                core.warning(`Failed to set milestone: ${e.message}`);
              }
            } else {
              core.info(`Milestone unchanged.`);
            }

            core.info('âœ… Auto-assignment complete.');
